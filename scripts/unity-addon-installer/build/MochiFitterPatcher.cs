// ============================================
// MochiFitter-Kai Patcher DLL
// Auto-generated by generate_patcher.py
// Version: 1.0.0
// ============================================
//
// このDLLはsmoothing_processor.pyに最適化パッチを適用します。
//
// 使用方法:
//   MochiFitterPatcher.ApplyPatches(filePath);   // パッチ適用
//   MochiFitterPatcher.RemovePatches(filePath);  // パッチ削除
//   MochiFitterPatcher.IsPatched(filePath);      // 適用状態確認
// ============================================

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace MochiFitterKai
{
    /// <summary>
    /// パッチエントリ定義
    /// </summary>
    public class PatchEntry
    {
        public string PatchId { get; set; }
        public string Description { get; set; }
        public string OriginalCode { get; set; }
        public string OptimizedCode { get; set; }
        public int LineHint { get; set; }
    }

    /// <summary>
    /// パッチ適用結果
    /// </summary>
    public class PatchResult
    {
        public bool Success { get; set; }
        public int PatchesApplied { get; set; }
        public int TotalPatches { get; set; }
        public List<string> AppliedPatchIds { get; set; }
        public List<string> SkippedPatchIds { get; set; }
        public List<string> Messages { get; set; }
        public string Error { get; set; }

        public PatchResult()
        {
            Messages = new List<string>();
            AppliedPatchIds = new List<string>();
            SkippedPatchIds = new List<string>();
        }
    }

    /// <summary>
    /// smoothing_processor.py 最適化パッチャー
    /// </summary>
    public static class MochiFitterPatcher
    {
        /// <summary>
        /// パッチャーバージョン
        /// </summary>
        public const string Version = "1.0.0";

        /// <summary>
        /// 総パッチ数
        /// </summary>
        public const int TotalPatchCount = 2;

        /// <summary>
        /// 最適化マーカー（ファイルヘッダー）
        /// </summary>
        private const string OptimizationMarker = "# MochiFitter-Kai Optimized";

        /// <summary>
        /// 完全適用マーカー
        /// </summary>
        private const string FullyAppliedMarker = "# Patches Applied: 2/2";

        /// <summary>
        /// パッチ定義リスト
        /// </summary>
        private static readonly PatchEntry[] Patches = new PatchEntry[]
        {
            new PatchEntry {
                PatchId = "blend_weights_vectorize_1",
                Description = "ウェイト合成ループのベクトル化 (1箇所目, line 402-406)",
                OriginalCode = "                            final_weights = np.zeros(len(vertex_coords), dtype=np.float32)\n                            \n                            for i in range(len(vertex_coords)):\n                                blend_factor = mask_weights[i]\n                                final_weights[i] = original_weights[i] * (1.0 - blend_factor) + smoothed_weights[i] * blend_factor",
                OptimizedCode = "                            # MochiFitter-Kai Optimized: NumPy vectorized blending (2544x faster)\n                            final_weights = original_weights * (1.0 - mask_weights) + smoothed_weights * mask_weights",
                LineHint = 402
            },
            new PatchEntry {
                PatchId = "blend_weights_vectorize_2",
                Description = "ウェイト合成ループのベクトル化 (2箇所目, line 477-480)",
                OriginalCode = "                        final_weights = np.zeros(len(vertex_coords), dtype=np.float32)\n                        for i in range(len(vertex_coords)):\n                            blend_factor = mask_weights[i]\n                            final_weights[i] = original_weights[i] * (1.0 - blend_factor) + smoothed_weights[i] * blend_factor",
                OptimizedCode = "                        # MochiFitter-Kai Optimized: NumPy vectorized blending (2544x faster)\n                        final_weights = original_weights * (1.0 - mask_weights) + smoothed_weights * mask_weights",
                LineHint = 477
            }
        };

        /// <summary>
        /// ファイルがパッチ適用済みかどうかを確認
        /// </summary>
        /// <param name="filePath">smoothing_processor.py のパス</param>
        /// <returns>パッチ適用済みの場合 true</returns>
        public static bool IsPatched(string filePath)
        {
            if (!File.Exists(filePath))
                return false;

            try
            {
                string content = File.ReadAllText(filePath, Encoding.UTF8);
                return content.Contains(OptimizationMarker);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// ファイルが完全にパッチ適用済みかどうかを確認
        /// </summary>
        /// <param name="filePath">smoothing_processor.py のパス</param>
        /// <returns>全パッチ適用済みの場合 true</returns>
        public static bool IsFullyPatched(string filePath)
        {
            if (!File.Exists(filePath))
                return false;

            try
            {
                string content = File.ReadAllText(filePath, Encoding.UTF8);
                return content.Contains(FullyAppliedMarker);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// パッチを適用
        /// </summary>
        /// <param name="filePath">smoothing_processor.py のパス</param>
        /// <returns>適用結果</returns>
        public static PatchResult ApplyPatches(string filePath)
        {
            var result = new PatchResult();
            result.TotalPatches = TotalPatchCount;

            if (!File.Exists(filePath))
            {
                result.Success = false;
                result.Error = "ファイルが見つかりません: " + filePath;
                return result;
            }

            try
            {
                string content = File.ReadAllText(filePath, Encoding.UTF8);

                // 改行コードを正規化（CRLF → LF）
                content = content.Replace("\r\n", "\n").Replace("\r", "\n");

                // 既に完全にパッチ適用済みの場合
                if (content.Contains(FullyAppliedMarker))
                {
                    result.Success = true;
                    result.PatchesApplied = TotalPatchCount;
                    result.Messages.Add("既に全パッチ適用済みです");
                    return result;
                }

                // 部分的に適用済みの場合は警告（ヘッダーがあるが完全適用ではない）
                if (content.Contains(OptimizationMarker) && !content.Contains(FullyAppliedMarker))
                {
                    result.Messages.Add("警告: 部分的にパッチが適用されています。再適用を試みます...");
                    // ヘッダーを削除して再適用を試みる
                    int headerEnd = content.IndexOf("# ============================================\n",
                        content.IndexOf(OptimizationMarker));
                    if (headerEnd > 0)
                    {
                        headerEnd = content.IndexOf("\n", headerEnd) + 1;
                        content = content.Substring(headerEnd);
                    }
                }

                // バックアップを作成（まだ存在しない場合のみ）
                string backupPath = filePath + ".bak";
                if (!File.Exists(backupPath))
                {
                    // オリジナルファイルを読み込んでバックアップ
                    string originalContent = File.ReadAllText(filePath, Encoding.UTF8);
                    File.WriteAllText(backupPath, originalContent, Encoding.UTF8);
                    result.Messages.Add("バックアップを作成: " + backupPath);
                }

                // パッチを適用（完全一致のみ）
                string modifiedContent = content;
                int newlyAppliedCount = 0;      // 今回新たに適用したパッチ数
                int alreadyAppliedCount = 0;    // 既に適用済みのパッチ数

                foreach (var patch in Patches)
                {
                    if (modifiedContent.Contains(patch.OriginalCode))
                    {
                        // オリジナルコードが存在 → パッチを適用
                        modifiedContent = modifiedContent.Replace(
                            patch.OriginalCode,
                            patch.OptimizedCode
                        );
                        result.Messages.Add("パッチ適用: " + patch.Description);
                        result.AppliedPatchIds.Add(patch.PatchId);
                        newlyAppliedCount++;
                    }
                    else if (modifiedContent.Contains(patch.OptimizedCode))
                    {
                        // 最適化コードが存在 → 既に適用済み
                        alreadyAppliedCount++;
                    }
                    else
                    {
                        // どちらも存在しない → コードが変更されている
                        result.Messages.Add("パッチスキップ（コード不一致）: " + patch.Description);
                        result.SkippedPatchIds.Add(patch.PatchId);
                    }
                }

                // 合計適用数 = 今回適用 + 既に適用済み
                int totalAppliedCount = newlyAppliedCount + alreadyAppliedCount;

                // ヘッダーマーカーを追加（1つ以上適用されている場合）
                if (totalAppliedCount > 0)
                {
                    string patchStatus = totalAppliedCount.ToString() + "/" + TotalPatchCount.ToString();
                    string header = "# ============================================" + Environment.NewLine +
                        "# MochiFitter-Kai Optimized" + Environment.NewLine +
                        "# Version: " + Version + Environment.NewLine +
                        "# Patches Applied: " + patchStatus + Environment.NewLine +
                        "# DO NOT REMOVE THIS HEADER" + Environment.NewLine +
                        "# ============================================" + Environment.NewLine;
                    modifiedContent = header + modifiedContent;
                }

                // ファイルを書き込み（変更があった場合のみ）
                if (newlyAppliedCount > 0 || (alreadyAppliedCount > 0 && !content.Contains(FullyAppliedMarker)))
                {
                    File.WriteAllText(filePath, modifiedContent, Encoding.UTF8);
                }

                result.Success = totalAppliedCount > 0;
                result.PatchesApplied = totalAppliedCount;

                if (totalAppliedCount == 0)
                {
                    result.Error = "適用可能なパッチがありませんでした（コードが異なる可能性があります）";
                }
                else if (totalAppliedCount < TotalPatchCount)
                {
                    result.Messages.Add("警告: 一部のパッチのみ適用されました (" + totalAppliedCount.ToString() + "/" + TotalPatchCount.ToString() + ")");
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Error = "パッチ適用中にエラー: " + ex.Message;
            }

            return result;
        }

        /// <summary>
        /// パッチを削除（バックアップから復元）
        /// </summary>
        /// <param name="filePath">smoothing_processor.py のパス</param>
        /// <returns>削除結果</returns>
        public static PatchResult RemovePatches(string filePath)
        {
            var result = new PatchResult();
            result.TotalPatches = TotalPatchCount;

            string backupPath = filePath + ".bak";

            if (!File.Exists(backupPath))
            {
                result.Success = false;
                result.Error = "バックアップファイルが見つかりません: " + backupPath;
                return result;
            }

            try
            {
                // バックアップから復元
                File.Copy(backupPath, filePath, true);
                result.Success = true;
                result.Messages.Add("バックアップから復元しました");
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Error = "復元中にエラー: " + ex.Message;
            }

            return result;
        }

        /// <summary>
        /// パッチ情報を取得
        /// </summary>
        /// <returns>パッチ定義のリスト</returns>
        public static PatchEntry[] GetPatchDefinitions()
        {
            return Patches;
        }
    }
}
